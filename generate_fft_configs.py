"""Helper script to generate FFT configurations for pre-defined FFT sizes."""

import os
import json


AUTOGEN_HEADER = """// This file is auto-generated by generate_fft_configs.py.
// Do not edit this file directly.
"""


def type_str_to_torch_dtype(type_str: str) -> str:
    """Convert a type string to a PyTorch dtype string."""
    type_map = {
        "float32": "torch.float32",
        "float64": "torch.float64",
        "complex64": "torch.complex64",
        "complex128": "torch.complex128",
    }
    return type_map.get(type_str, type_str)


def type_str_to_cuda_type(type_str: str) -> str:
    """Convert a type string to a CUDA type string."""
    type_map = {
        "float32": "float",
        "float64": "double",
        "complex64": "float2",
        "complex128": "double2",
    }
    return type_map.get(type_str, type_str)


class FFT1DConfigGenerator:
    """Container class to create FFT instantiations from a configuration dictionary.

    Attributes
    ----------
    function_name : str
        The name of the templated function to generate instances of.
    fft_sizes : list[int]
        The list of FFT sizes to generate instances for.
    fft_types : list[str | tuple[str, str]]
        The list of FFT types to generate instances for. For in-place FFTs, this is a
        single string. When the FFT is out-of-place (e.g. for R2C or C2R), then this
        parameter is a tuple of the input and output type, respectively.
    is_inplace_fft : bool
        Whether the FFT is in-place or out-of-place.
    is_forward_fft : bool
        Whether the FFT is forward or inverse. This is used to determine the
        implementation of the FFT.
    """

    function_name: str
    fft_sizes: list[int]
    fft_types: list[str | tuple[str, str]]
    is_inplace_fft: bool
    is_forward_fft: bool

    @classmethod
    def from_config(cls, config: dict) -> "FFTConfigGenerator":
        """Create an FFTConfigGenerator instance from a configuration dictionary."""
        assert "function_name" in config, "Missing 'function_name' in config"
        assert "fft_sizes" in config, "Missing 'fft_sizes' in config"
        assert "fft_types" in config, "Missing 'fft_types' in config"
        assert "is_inplace_fft" in config, "Missing 'is_inplace_fft' in config"
        assert "is_forward_fft" in config, "Missing 'is_forward_fft' in config"

        function_name = config["function_name"]
        fft_sizes = config["fft_sizes"]
        fft_types = config["fft_types"]
        is_inplace_fft = config["is_inplace_fft"]
        is_forward_fft = config["is_forward_fft"]

        return cls(function_name, fft_sizes, fft_types, is_inplace_fft, is_forward_fft)

    def __init__(
        self,
        function_name: str,
        fft_sizes: list[int],
        fft_types: list[str],
        is_inplace_fft: bool,
        is_forward_fft: bool,
    ):
        """Initialize the FFTConfigGenerator with sizes, types, and direction."""
        if not is_inplace_fft:
            fft_types = [tuple(x) for x in fft_types]

        self.function_name = function_name
        self.fft_sizes = fft_sizes
        self.fft_types = fft_types
        self.is_inplace_fft = is_inplace_fft
        self.is_forward_fft = is_forward_fft

    def generate_cuda_static_asserts(self) -> str:
        """Generates CUDA static asserts for the FFT configuration."""
        size_assertion_cases = []
        for size in self.fft_sizes:
            size_assertion_cases.append(f"FFTSize == {size}")

        # Combine the defined sizes into a single static assertion statement
        size_assertion_str = " || ".join(size_assertion_cases)
        size_assertion = f'static_assert({size_assertion_str}, "FFT size must be one of the predefined sizes of {self.fft_sizes}");'

        # Case for in-place FFTs
        if self.is_inplace_fft:
            assert isinstance(
                self.fft_types[0], str
            ), "FFT types must be a single type for in-place FFTs"

            type_assertion_cases = []
            for type_str in self.fft_types:
                type_assertion_cases.append(
                    f"std::is_same_v<T, {type_str_to_cuda_type(type_str)}>"
                )

            # Combine the defined types into a single static assertion statement
            type_assertion_str = " || ".join(type_assertion_cases)
            type_assertion = f'static_assert({type_assertion_str}, "FFT type must be one of the predefined types of {[type_str_to_cuda_type(x) for x in self.fft_types]}");'
        elif not self.is_inplace_fft:
            assert (
                isinstance(self.fft_types[0], tuple) and len(self.fft_types[0]) == 2
            ), "FFT types must be tuple of input and output types for out-of-place FFTs"

            type_assertion_cases_input = []
            type_assertion_cases_output = []
            for input_type_str, output_type_str in self.fft_types:
                type_assertion_cases_input.append(
                    f"std::is_same_v<Input_T, {type_str_to_cuda_type(input_type_str)}>"
                )
                type_assertion_cases_output.append(
                    f"std::is_same_v<Output_T, {type_str_to_cuda_type(output_type_str)}>"
                )

            # Combine the defined types into a single static assertion statement
            type_assertion_str_input = " || ".join(type_assertion_cases_input)
            type_assertion_str_output = " || ".join(type_assertion_cases_output)
            type_assertion_input = f'static_assert({type_assertion_str_input}, "FFT input type must be one of the predefined types of {[type_str_to_cuda_type(x[0]) for x in self.fft_types]}");'
            type_assertion_output = f'static_assert({type_assertion_str_output}, "FFT output type must be one of the predefined types of {[type_str_to_cuda_type(x[1]) for x in self.fft_types]}");'
            type_assertion = f"{type_assertion_input}\n{type_assertion_output}"
        else:
            raise ValueError("FFT type must be either in-place or out-of-place")

        return f"{size_assertion}\n{type_assertion}"

    def generate_implementations(self) -> str:
        """Generates the implementation cases for the FFT configuration."""
        cases = []
        if self.is_inplace_fft:
            for type_str in self.fft_types:
                for size in self.fft_sizes:
                    tmp = f"template int {self.function_name}<{type_str_to_cuda_type(type_str)}, {size}u>({type_str_to_cuda_type(type_str)}* data);"
                    cases.append(tmp)
        else:
            for input_type_str, output_type_str in self.fft_types:
                for size in self.fft_sizes:
                    tmp = f"template int {self.function_name}<{type_str_to_cuda_type(input_type_str)}, {type_str_to_cuda_type(output_type_str)}, {size}u, {'true' if self.is_forward_fft else 'false'}>({type_str_to_cuda_type(input_type_str)}* data, {type_str_to_cuda_type(output_type_str)}* out);"
                    cases.append(tmp)
        return "\n".join(cases)

    def generate_binding_cases(self) -> str:
        """Generates the binding cases for the FFT configuration."""
        cases = []
        if self.is_inplace_fft:
            for type_str in self.fft_types:
                for size in self.fft_sizes:
                    tmp = f"case {size}: {self.function_name}<{type_str_to_cuda_type(type_str)}, {size}u>(data_ptr); break;"
                    cases.append(tmp)
        else:
            for input_type_str, output_type_str in self.fft_types:
                for size in self.fft_sizes:
                    tmp = f"case {size}: {self.function_name}<{type_str_to_cuda_type(input_type_str)}, {type_str_to_cuda_type(output_type_str)}, {size}u, {'true' if self.is_forward_fft else 'false'}>(input_ptr, output_ptr); break;"
                    cases.append(tmp)

        cases.append("default:")
        cases.append(f"std::string supported_sizes = \"{self.fft_sizes}\";")
        cases.append("TORCH_CHECK(false, \"Unsupported FFT size \" + std::to_string(fft_size) +  \", supported sizes: \" + supported_sizes);")

        return "\n".join(cases)


def generate_files_from_configs(configs: dict) -> None:
    """Generates implementations for multiple FFT configurations."""
    output_dir = "src/generated"

    # Loop over all the 1-dimensional FFT configurations
    for name, config in configs.items():
        cfg_gen = FFT1DConfigGenerator.from_config(config)

        # Generate and write the implementation cases to  a file
        impl_cases = cfg_gen.generate_implementations()
        with open(os.path.join(output_dir, f"{name}_impl.inc"), "w") as f:
            f.write(AUTOGEN_HEADER)
            f.write(impl_cases)

        # Generate the CUDA static asserts
        cuda_static_asserts = cfg_gen.generate_cuda_static_asserts()
        with open(
            os.path.join(output_dir, f"{name}_asserts.inc"), "w"
        ) as f:
            f.write(AUTOGEN_HEADER)
            f.write(cuda_static_asserts)

        # Generate the binding cases
        binding_cases = cfg_gen.generate_binding_cases()
        with open(os.path.join(output_dir, f"{name}_cases.inc"), "w") as f:
            f.write(AUTOGEN_HEADER)
            f.write(binding_cases)


def main():
    """Main function to read the configuration and generate files."""
    # Load the configuration from a JSON file
    with open("fft_sizes_config.json", "r") as f:
        configs = json.load(f)

    # Generate the files from the configurations
    generate_files_from_configs(configs)


if __name__ == "__main__":
    main()
